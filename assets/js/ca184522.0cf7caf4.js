"use strict";(self.webpackChunkpages=self.webpackChunkpages||[]).push([[4801],{6391:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"extensions/write-extensions","title":"Write your own extension","description":"Nuget","source":"@site/docs/extensions/01-write-extensions.md","sourceDirName":"extensions","slug":"/extensions/write-extensions","permalink":"/docs/extensions/write-extensions","draft":false,"unlisted":false,"editUrl":"https://github.com/aweXpect/aweXpect/tree/main/Docs/pages/docs/extensions/01-write-extensions.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"extensionsSidebar","previous":{"title":"aweXpect.Testably","permalink":"/docs/extensions/project/Testably/index"}}');var s=n(4848),a=n(8453);const o={},r="Write your own extension",l={},c=[{value:"Expectations",id:"expectations",level:2},{value:"ExpectationBuilder",id:"expectationbuilder",level:3},{value:"Constraints",id:"constraints",level:3},{value:"Customization",id:"customization",level:2},{value:"Add a simple customization value",id:"add-a-simple-customization-value",level:3},{value:"Add a customization group",id:"add-a-customization-group",level:3}];function u(e){const t={a:"a",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"write-your-own-extension",children:"Write your own extension"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://www.nuget.org/packages/aweXpect.Core",children:(0,s.jsx)(t.img,{src:"https://img.shields.io/nuget/v/aweXpect.Core?label=aweXpect.Core",alt:"Nuget"})})}),"\n",(0,s.jsxs)(t.p,{children:["This library will never be able to cope with all ideas and use cases. Therefore, it is possible to use the ",(0,s.jsxs)(t.a,{href:"https://www.nuget.org/packages/aweXpect.Core/",children:["\n",(0,s.jsx)(t.code,{children:"aweXpect.Core"})]})," package and write your own extensions.\nGoal of this package is to be more stable than the main aweXpect package, so reduce the risk of version conflicts\nbetween different extensions."]}),"\n",(0,s.jsx)(t.h2,{id:"expectations",children:"Expectations"}),"\n",(0,s.jsxs)(t.p,{children:["You can extend the expectations for any types, by adding extension methods on ",(0,s.jsx)(t.code,{children:"IThat<TType>"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["If you want to verify that a ",(0,s.jsx)(t.code,{children:"string"})," is an absolute path, you specify the following method signature:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",children:'/// <summary>\n///     Verifies that the <paramref name="subject"/> is an absolute path.\n/// </summary>\npublic static AndOrResult<string, IThat<string>> IsAbsolutePath(this IThat<string> subject)\n{\n    // ...\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"expectationbuilder",children:"ExpectationBuilder"}),"\n",(0,s.jsxs)(t.p,{children:["The next step is to extract the ",(0,s.jsx)(t.code,{children:"ExpectationBuilder"}),". In order to keep the automatic code suggestions for developers\nclear, you have to cast the ",(0,s.jsx)(t.code,{children:"IThat<TType>"})," interface to ",(0,s.jsx)(t.code,{children:"IExpectThat<TType>"}),", which will then give access to the\n",(0,s.jsx)(t.code,{children:"ExpectationBuilder"})," property.\nTo improve readability you can copy the following internal extension method into your project:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",children:'[ExcludeFromCodeCoverage]\ninternal static IExpectThat<T> Get<T>(this IThat<T> subject)\n{\n    if (subject is IExpectThat<T> thatIs)\n    {\n        return thatIs;\n    }\n\n    throw new NotSupportedException("IThat<T> must also implement IExpectThat<T>");\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["You can then use the ",(0,s.jsx)(t.code,{children:"ExpectationBuilder"})," to add a ",(0,s.jsx)(t.code,{children:"IsAbsolutePathConstraint"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",children:"public static AndOrResult<string, IThat<string>> IsAbsolutePath(this IThat<string> subject)\n    => new(subject.Get().ExpectationBuilder.AddConstraint((it, grammars)\n            => new IsAbsolutePathConstraint(it, grammars)),\n        subject);\n"})}),"\n",(0,s.jsx)(t.h3,{id:"constraints",children:"Constraints"}),"\n",(0,s.jsxs)(t.p,{children:["The basis for expectations are constraints. You can add different constraints to the ",(0,s.jsx)(t.code,{children:"ExpectationBuilder"})," that is\navailable for the ",(0,s.jsx)(t.code,{children:"IThat<T>"}),". They differ in the input and output parameters for the ",(0,s.jsx)(t.code,{children:"IsMetBy"})," method:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"IValueConstraint<T>"}),(0,s.jsx)(t.br,{}),"\n","It receives the actual value ",(0,s.jsx)(t.code,{children:"T"})," and returns a ",(0,s.jsx)(t.code,{children:"ConstraintResult"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"IAsyncConstraint<T>"}),(0,s.jsx)(t.br,{}),"\n","It receives the actual value ",(0,s.jsx)(t.code,{children:"T"})," and a ",(0,s.jsx)(t.code,{children:"CancellationToken"})," and returns the ",(0,s.jsx)(t.code,{children:"ConstraintResult"})," asynchronously.",(0,s.jsx)(t.br,{}),"\n",(0,s.jsxs)(t.em,{children:["Use it when you need asynchronous functionality or access to the timeout ",(0,s.jsx)(t.code,{children:"CancellationToken"}),"."]})]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"IContextConstraint<T>"})," / ",(0,s.jsx)(t.code,{children:"IAsyncContextConstraint<T>"}),(0,s.jsx)(t.br,{}),"\n","Similar to the ",(0,s.jsx)(t.code,{children:"IValueConstraint<T>"})," and ",(0,s.jsx)(t.code,{children:"IAsyncConstraint<T>"})," respectively but receives an additional\n",(0,s.jsx)(t.code,{children:"IEvaluationContext"})," parameter that allows storing and receiving data between expectations.",(0,s.jsx)(t.br,{}),"\n",(0,s.jsxs)(t.em,{children:["This mechanism is used for example to avoid enumerating an ",(0,s.jsx)(t.code,{children:"IEnumerable"})," multiple times across multiple constraints."]})]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",children:'/// <summary>\n///     This example does NOT support the negated case!\n/// </summary>\nprivate sealed class IsAbsolutePathConstraint(string it, ExpectationGrammars grammars)\n    : ConstraintResult(grammars),\n        IValueConstraint<string>\n{\n    private string? _actual;\n    public ConstraintResult IsMetBy(string actual)\n    {\n        _actual = actual;\n        Outcome = Path.IsPathRooted(actual) ? Outcome.Success : Outcome.Failure;\n        return this;\n    }\n\n    public override void AppendExpectation(StringBuilder stringBuilder, string? indentation = null)\n        => stringBuilder.Append("is an absolute path");\n\n    public override void AppendResult(StringBuilder stringBuilder, string? indentation = null)\n    {\n        stringBuilder.Append(it).Append(" was ");\n        Formatter.Format(stringBuilder, _actual);\n    }\n\n    public override bool TryGetValue<TValue>([NotNullWhen(true)] out TValue? value) where TValue : default\n    {\n        if (_actual is TValue typedValue)\n        {\n            value = typedValue;\n            return true;\n        }\n\n        value = default;\n        return typeof(string).IsAssignableTo(typeof(TValue));\n    }\n\n    public override ConstraintResult Negate() => this;\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["All constraints should also provide the expectations and results for the negated case (so that they are compatible with\n",(0,s.jsx)(t.code,{children:"DoesNotComplyWith"}),")."]}),"\n",(0,s.jsxs)(t.p,{children:["In order to streamline common cases, the recommended practice is to use the same class also for the ",(0,s.jsx)(t.code,{children:"ConstraintResult"}),";\nin most cases with one of the following helper classes:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"ConstraintResult.WithValue<T>"}),"\nYou have to set the ",(0,s.jsx)(t.code,{children:"Actual"})," property in the ",(0,s.jsx)(t.code,{children:"IsMetBy"})," method and overwrite ",(0,s.jsx)(t.code,{children:"AppendNormalExpectation"})," and\n",(0,s.jsx)(t.code,{children:"AppendNegatedExpectation"})," as well as either the corresponding ",(0,s.jsx)(t.code,{children:"AppendNormalResult"})," and ",(0,s.jsx)(t.code,{children:"AppendNegatedResult"})," or the\ncommon method for both cases ",(0,s.jsx)(t.code,{children:"AppendResult"})," (when the result text is identical in both cases)"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"ConstraintResult.WithNotNullValue<T>"}),"\nSimilar to ",(0,s.jsx)(t.code,{children:"ConstraintResult.WithValue<T>"}),", but will automatically include a check that Actual is not ",(0,s.jsx)(t.code,{children:"null"})," with the\ngeneric result text."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"ConstraintResult.WithEqualToValue<T>"}),"\nEnsures consistent ",(0,s.jsx)(t.code,{children:"null"}),"-handling when comparing two values for equality. Similar to ",(0,s.jsx)(t.code,{children:"ConstraintResult.WithValue<T>"}),",\nbut you have to also provide a flag, indicating if the expected value is ",(0,s.jsx)(t.code,{children:"null"})," or not."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"With these the above example could be written (with support for the negated case):"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",children:'private sealed class IsAbsolutePathConstraint(string it, ExpectationGrammars grammars)\n    : ConstraintResult.WithValue<string>(grammars),\n        IValueConstraint<string>\n{\n    public ConstraintResult IsMetBy(string actual)\n    {\n        Actual = actual;\n        Outcome = Path.IsPathRooted(actual) ? Outcome.Success : Outcome.Failure;\n        return this;\n    }\n\n    protected override void AppendNormalExpectation(StringBuilder stringBuilder, string? indentation = null)\n        => stringBuilder.Append("is an absolute path");\n\n    protected override void AppendNormalResult(StringBuilder stringBuilder, string? indentation = null)\n    {\n        stringBuilder.Append(it).Append(" was ");\n        Formatter.Format(stringBuilder, Actual);\n    }\n\n    protected override void AppendNegatedExpectation(StringBuilder stringBuilder, string? indentation = null)\n        => stringBuilder.Append("is no negated path");\n\n    protected override void AppendNegatedResult(StringBuilder stringBuilder, string? indentation = null)\n    {\n        stringBuilder.Append(it).Append(" was ");\n        Formatter.Format(stringBuilder, Actual);\n    }\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["This then also allows you to write an explicit negated expectation with the same constraint using the ",(0,s.jsx)(t.code,{children:".Invert()"}),"\nmethod:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",children:'/// <summary>\n///     Verifies that the <paramref name="subject"/> is no absolute path.\n/// </summary>\npublic static AndOrResult<string, IThat<string>> IsNoAbsolutePath(\n    this IThat<string> subject)\n    => new(subject.ThatIs().ExpectationBuilder.AddConstraint((it, grammars)\n            => new IsAbsolutePathConstraint(it, grammars).Invert()),\n        subject);\n'})}),"\n",(0,s.jsx)(t.h2,{id:"customization",children:"Customization"}),"\n",(0,s.jsxs)(t.p,{children:["You can add you own ",(0,s.jsx)(t.a,{href:"/docs/expectations/advanced/customization",children:"customizations"})," on top of the ",(0,s.jsx)(t.code,{children:"AwexpectCustomization"}),"\nclass by adding extension methods."]}),"\n",(0,s.jsx)(t.h3,{id:"add-a-simple-customization-value",children:"Add a simple customization value"}),"\n",(0,s.jsxs)(t.p,{children:["You can add a simple customizable value (e.g. an ",(0,s.jsx)(t.code,{children:"int"}),"):"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",children:"public static class MyCustomizationExtensions\n{\n    public static ICustomizationValueSetter<int> MyCustomization(this AwexpectCustomization awexpectCustomization)\n        => new CustomizationValue<int>(awexpectCustomization, nameof(MyCustomization), 42);\n\n    internal class CustomizationValue<TValue>(IAwexpectCustomization awexpectCustomization, string key, TValue defaultValue)\n        : ICustomizationValueSetter<TValue>\n    {\n        public TValue Get()\n            => awexpectCustomization.Get(key, defaultValue);\n\n        public CustomizationLifetime Set(TValue value)\n            => awexpectCustomization.Set(key, value);\n    }\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"This allows expectations to access the value:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",children:" // will return the default value of 42\nint myCustomization = Customize.aweXpect.MyCustomization().Get();\n"})}),"\n",(0,s.jsx)(t.p,{children:"And users can customize the value:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",children:"using (Customize.aweXpect.MyCustomization().Set(43))\n{\n    // will now return 43\n    int myCustomization = Customize.aweXpect.MyCustomization().Get();\n}\n// will now return again the default value of 42, because the customization lifetime was disposed\n_ = Customize.aweXpect.MyCustomization().Get();\n"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.em,{children:"Note: you can also use this mechanism for complex objects like classes, but they can only be changed as a whole (and\nnot individual properties)"})}),"\n",(0,s.jsx)(t.h3,{id:"add-a-customization-group",children:"Add a customization group"}),"\n",(0,s.jsx)(t.p,{children:"You can also add a group of customization values, that can be changed individually or as a whole"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",children:"public static class JsonAwexpectCustomizationExtensions\n{\n    public static JsonCustomization Json(this AwexpectCustomization awexpectCustomization)\n        => new(awexpectCustomization);\n\n    public class JsonCustomization : ICustomizationValueUpdater<JsonCustomizationValue>\n    {\n        private readonly IAwexpectCustomization _awexpectCustomization;\n\n        internal JsonCustomization(IAwexpectCustomization awexpectCustomization)\n        {\n            _awexpectCustomization = awexpectCustomization;\n            DefaultJsonDocumentOptions = new CustomizationValue<JsonDocumentOptions>(\n                () => Get().DefaultJsonDocumentOptions,\n                v => Update(p => p with { DefaultJsonDocumentOptions = v }));\n            DefaultJsonSerializerOptions = new CustomizationValue<JsonSerializerOptions>(\n                () => Get().DefaultJsonSerializerOptions,\n                v => Update(p => p with { DefaultJsonSerializerOptions = v }));\n        }\n\n        public ICustomizationValueSetter<JsonDocumentOptions> DefaultJsonDocumentOptions { get; }\n        public ICustomizationValueSetter<JsonSerializerOptions> DefaultJsonSerializerOptions { get; }\n\n        public JsonCustomizationValue Get()\n            => _awexpectCustomization.Get(nameof(Json), new JsonCustomizationValue());\n\n        public CustomizationLifetime Update(Func<JsonCustomizationValue, JsonCustomizationValue> update)\n            => _awexpectCustomization.Set(nameof(Json), update(Get()));\n    }\n\n    public record JsonCustomizationValue\n    {\n        public JsonDocumentOptions DefaultJsonDocumentOptions { get; set; } = new()\n        {\n            AllowTrailingCommas = true\n        };\n        public JsonSerializerOptions DefaultJsonSerializerOptions { get; set; } = new()\n        {\n            AllowTrailingCommas = true\n        };\n    }\n\n    private sealed class CustomizationValue<TValue>(\n        Func<TValue> getter,\n        Func<TValue, CustomizationLifetime> setter)\n        : ICustomizationValueSetter<TValue>\n    {\n        public TValue Get() => getter();\n        public CustomizationLifetime Set(TValue value) => setter(value);\n    }\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"This allows expectations to access values either individually or for the whole group:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",children:" // both will return the default value 'true'\nint myCustomization1 = Customize.aweXpect.Json().Get().DefaultJsonDocumentOptions.AllowTrailingCommas;\nint myCustomization2 = Customize.aweXpect.Json().DefaultJsonDocumentOptions.Get().AllowTrailingCommas;\n"})}),"\n",(0,s.jsx)(t.p,{children:"And users can customize either individual values or the whole group:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-csharp",children:"// update a single value (keeping the other values)\nJsonSerializerOptions mySerializerOptions = new();\nusing (Customize.aweXpect.Json().DefaultJsonSerializerOptions.Set(mySerializerOptions))\n{\n    // will use `mySerializerOptions` for the `JsonSerializerOptions`\n\t// but keep any configured `JsonDocumentOptions`\n}\n\n// ...or update the whole group\nJsonCustomizationValue myCustomization = new();\nusing (Customize.aweXpect.Json().Update(_ => myCustomization))\n{\n    // will use the all set properties from the `myCustomization`\n}\n"})})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var i=n(6540);const s={},a=i.createContext(s);function o(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);