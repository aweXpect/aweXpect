"use strict";(globalThis.webpackChunkpages=globalThis.webpackChunkpages||[]).push([[2432],{6814:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>c,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"extensions/project/Reflection/index","title":"aweXpect.Reflection","description":"Nuget","source":"@site/docs/extensions/project/Reflection/00-index.md","sourceDirName":"extensions/project/Reflection","slug":"/extensions/project/Reflection/index","permalink":"/docs/extensions/project/Reflection/index","draft":false,"unlisted":false,"editUrl":"https://github.com/aweXpect/aweXpect/tree/main/Docs/pages/docs/extensions/project/Reflection/00-index.md","tags":[],"version":"current","sidebarPosition":0,"frontMatter":{},"sidebar":"extensionsSidebar","previous":{"title":"aweXpect.Web","permalink":"/docs/extensions/project/Web/index"},"next":{"title":"Feature Comparison with FluentAssertions","permalink":"/docs/extensions/project/Reflection/fluentassertions-comparison"}}');var a=s(4848),i=s(8453);const c={},r="aweXpect.Reflection",l={},o=[{value:"Overview",id:"overview",level:2},{value:"Advanced Filtering with <code>In</code>",id:"advanced-filtering-with-in",level:2},{value:"Assembly Selection",id:"assembly-selection",level:3},{value:"Type Selection",id:"type-selection",level:3},{value:"Member Navigation",id:"member-navigation",level:3},{value:"Advanced Filtering",id:"advanced-filtering",level:3},{value:"Type Filters",id:"type-filters",level:4},{value:"Method Filters",id:"method-filters",level:4},{value:"Property, Field, Event, and Constructor Filters",id:"property-field-event-and-constructor-filters",level:4},{value:"Combining Filters",id:"combining-filters",level:3},{value:"Real-World Examples",id:"real-world-examples",level:3},{value:"Assemblies",id:"assemblies",level:2},{value:"Name",id:"name",level:3},{value:"Dependencies",id:"dependencies",level:3},{value:"Attributes",id:"attributes",level:3},{value:"Types",id:"types",level:2},{value:"Name / Namespace",id:"name--namespace",level:3},{value:"Type Kinds",id:"type-kinds",level:3},{value:"Access Modifiers",id:"access-modifiers",level:3},{value:"Attributes",id:"attributes-1",level:3},{value:"Methods",id:"methods",level:2},{value:"Name",id:"name-1",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Return Types",id:"return-types",level:3},{value:"Access Modifiers",id:"access-modifiers-1",level:3},{value:"Attributes",id:"attributes-2",level:3},{value:"Properties",id:"properties",level:2},{value:"Name and Type",id:"name-and-type",level:3},{value:"Access Modifiers",id:"access-modifiers-2",level:3},{value:"Attributes",id:"attributes-3",level:3},{value:"Fields",id:"fields",level:2},{value:"Name",id:"name-2",level:3},{value:"Access Modifiers",id:"access-modifiers-3",level:3},{value:"Attributes",id:"attributes-4",level:3},{value:"Events",id:"events",level:2},{value:"Name",id:"name-3",level:3},{value:"Access Modifiers",id:"access-modifiers-4",level:3},{value:"Attributes",id:"attributes-5",level:3},{value:"Constructors",id:"constructors",level:2},{value:"Parameters",id:"parameters-1",level:3},{value:"Attributes",id:"attributes-6",level:3},{value:"String Matching Options",id:"string-matching-options",level:2},{value:"Exact Matching",id:"exact-matching",level:3},{value:"Prefix/Suffix Matching",id:"prefixsuffix-matching",level:3},{value:"Case Sensitivity",id:"case-sensitivity",level:3},{value:"Wildcards and Patterns",id:"wildcards-and-patterns",level:3},{value:"Regular Expressions",id:"regular-expressions",level:3},{value:"Collection Operations",id:"collection-operations",level:2},{value:"Apply expectations to all items",id:"apply-expectations-to-all-items",level:3},{value:"Use quantifiers",id:"use-quantifiers",level:3},{value:"Combine with LINQ",id:"combine-with-linq",level:3},{value:"Configuration and Customization",id:"configuration-and-customization",level:2},{value:"Assembly Exclusions",id:"assembly-exclusions",level:3},{value:"Thread Safety",id:"thread-safety",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3}];function h(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"awexpectreflection",children:"aweXpect.Reflection"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://www.nuget.org/packages/aweXpect.Reflection",children:(0,a.jsx)(t.img,{src:"https://img.shields.io/nuget/v/aweXpect.Reflection",alt:"Nuget"})})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"https://github.com/aweXpect/aweXpect.Reflection",children:"aweXpect.Reflection"})," contains expectations for reflection types."]}),"\n",(0,a.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(t.p,{children:"This library contains expectations on reflection types:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.reflection.assembly",children:(0,a.jsx)(t.code,{children:"Assembly"})})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.type",children:(0,a.jsx)(t.code,{children:"Type"})})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.reflection.constructorinfo",children:(0,a.jsx)(t.code,{children:"ConstructorInfo"})})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.reflection.eventinfo",children:(0,a.jsx)(t.code,{children:"EventInfo"})})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.reflection.fieldinfo",children:(0,a.jsx)(t.code,{children:"FieldInfo"})})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.reflection.methodinfo",children:(0,a.jsx)(t.code,{children:"MethodInfo"})})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.reflection.propertyinfo",children:(0,a.jsx)(t.code,{children:"PropertyInfo"})})}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["You can apply the expectations either on a single type or a collection of types (e.g. ",(0,a.jsx)(t.code,{children:"Assembly[]"})," or\n",(0,a.jsx)(t.code,{children:"IEnumerable<Type?>"}),")."]}),"\n",(0,a.jsxs)(t.h2,{id:"advanced-filtering-with-in",children:["Advanced Filtering with ",(0,a.jsx)(t.code,{children:"In"})]}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"In"})," helper provides powerful filtering capabilities to construct collections of reflection types that match specific criteria. This allows for complex queries across assemblies, types, and their members."]}),"\n",(0,a.jsx)(t.h3,{id:"assembly-selection",children:"Assembly Selection"}),"\n",(0,a.jsx)(t.p,{children:"You can select assemblies in various ways:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"// All currently loaded assemblies (excluding system assemblies)\nIn.AllLoadedAssemblies()\n\n// Specific assemblies\nIn.Assemblies(assembly1, assembly2)\nIn.Assemblies(assemblyCollection)\n\n// Assembly containing a specific type\nIn.AssemblyContaining<MyClass>()\nIn.AssemblyContaining(typeof(MyClass))\n\n// Special assemblies\nIn.EntryAssembly()\nIn.ExecutingAssembly()\n"})}),"\n",(0,a.jsx)(t.h3,{id:"type-selection",children:"Type Selection"}),"\n",(0,a.jsx)(t.p,{children:"From assemblies, you can navigate to types:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"// All types in assemblies\nIn.AllLoadedAssemblies().Types()\n\n// Specific types\nIn.Type<MyClass>()\nIn.Type(typeof(MyClass))\nIn.Types<Class1, Class2>()\nIn.Types<Class1, Class2, Class3>()\nIn.Types(type1, type2, type3)\n"})}),"\n",(0,a.jsx)(t.h3,{id:"member-navigation",children:"Member Navigation"}),"\n",(0,a.jsx)(t.p,{children:"From types, you can navigate to their members:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"Type myType = typeof(MyClass);\n\n// Get all members\nIn.Type(myType).Methods()\nIn.Type(myType).Properties()\nIn.Type(myType).Fields()\nIn.Type(myType).Events()\nIn.Type(myType).Constructors()\n\n// Navigate back to declaring types from members\nIn.AllLoadedAssemblies().Methods().DeclaringTypes()\n"})}),"\n",(0,a.jsx)(t.h3,{id:"advanced-filtering",children:"Advanced Filtering"}),"\n",(0,a.jsx)(t.p,{children:"You can apply complex filters to narrow down your selections:"}),"\n",(0,a.jsx)(t.h4,{id:"type-filters",children:"Type Filters"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'// Filter by type characteristics\nIn.AllLoadedAssemblies().Types()\n    .WhichAreClasses()\n    .WhichArePublic()\n    .WhichAreAbstract()\n    .WhichAreSealed()\n    .WhichAreStatic()\n    .WhichAreGeneric()\n    .WhichAreNested()\n\t\n// Alternatively\nIn.AllLoadedAssemblies().Public.Abstract.Classes()\nIn.AllLoadedAssemblies().Internal.Generic.Interfaces()\n\n// Filter by name or namespace\nIn.AllLoadedAssemblies().Types()\n    .WithName("Service").AsSuffix()\n    .WithNamespace("MyApp.Services")\n\n// Filter by inheritance\nIn.AllLoadedAssemblies().Types()\n    .WhichInheritFrom<BaseClass>()\n    .WhichInheritFrom(typeof(IInterface))\n\n// Filter by attributes\nIn.AllLoadedAssemblies().Types()\n    .With<ObsoleteAttribute>()\n    .With<DescriptionAttribute>(a => a.Description.Contains("important"))\n\n// Filter by custom predicates\nIn.AllLoadedAssemblies().Types()\n    .WhichSatisfy(t => t.Name.StartsWith("Test"))\n'})}),"\n",(0,a.jsx)(t.h4,{id:"method-filters",children:"Method Filters"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'// Filter by method characteristics\nIn.AllLoadedAssemblies().Methods()\n    .WhichArePublic()\n    .WhichArePrivate()\n    .WhichAreProtected()\n    .WhichAreInternal()\n\t\n// Alternatively\nIn.AllLoadedAssemblies().Public.Methods()\nIn.AllLoadedAssemblies().Private.Protected.Methods()\n\n// Filter by return types\nIn.AllLoadedAssemblies().Methods()\n    .WhichReturn<Task>()           // Methods returning Task or Task<T>\n    .WhichReturnExactly<Task>()    // Methods returning exactly Task\n    .WhichReturn<string>()\n\n// Filter by parameters\nIn.AllLoadedAssemblies().Methods()\n    .WithoutParameters()\n    .WithParameter<string>()\n    .WithParameter<int>("count")\n    .WithParameterCount(2)\n\n// Filter by attributes\nIn.AllLoadedAssemblies().Methods()\n    .With<TestAttribute>()\n    .With<ObsoleteAttribute>(a => a.Message != null)\n\n// Filter by name\nIn.AllLoadedAssemblies().Methods()\n    .WithName("Get").AsPrefix()\n    .WithName("Async").AsSuffix()\n'})}),"\n",(0,a.jsx)(t.h4,{id:"property-field-event-and-constructor-filters",children:"Property, Field, Event, and Constructor Filters"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'// Properties\nIn.AllLoadedAssemblies().Public.Properties()\n    .OfType<string>()\n    .OfExactType<List<int>>()\n    .WithName("Id").AsSuffix()\n    .With<RequiredAttribute>()\n\n// Fields\nIn.AllLoadedAssemblies().Private.Fields()\n    .OfType<ILogger>()\n    .WithName("_").AsPrefix()\n    .With<NonSerializedAttribute>()\n\n// Events\nIn.AllLoadedAssemblies().Public.Events()\n    .WithName("Changed").AsSuffix()\n    .With<ObsoleteAttribute>()\n\n// Constructors\nIn.AllLoadedAssemblies().Public.Constructors()\n    .WithoutParameters()\n    .WithParameter<string>()\n    .WithParameterCount(1)\n    .With<JsonConstructorAttribute>()\n'})}),"\n",(0,a.jsx)(t.h3,{id:"combining-filters",children:"Combining Filters"}),"\n",(0,a.jsxs)(t.p,{children:["Filters can be chained and combined using ",(0,a.jsx)(t.code,{children:"Or"})," methods:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'// Multiple attribute options\nIn.AllLoadedAssemblies().Methods()\n    .With<FactAttribute>().OrWith<TheoryAttribute>()\n\n// Multiple return type options\nIn.AllLoadedAssemblies().Methods()\n    .WhichReturn<Task>().OrReturn<ValueTask>()\n\n// Complex combinations\nIn.AllLoadedAssemblies().Types()\n    .WhichAreClasses()\n    .WhichArePublic()\n    .WithName("Service").AsSuffix()\n    .Methods()\n    .WhichArePublic()\n    .With<HttpGetAttribute>().OrWith<HttpPostAttribute>()\n'})}),"\n",(0,a.jsx)(t.h3,{id:"real-world-examples",children:"Real-World Examples"}),"\n",(0,a.jsxs)(t.p,{children:["Here are some practical examples of using the ",(0,a.jsx)(t.code,{children:"In"})," helper:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'// Verify all test classes follow naming convention\nawait Expect.That(In.AllLoadedAssemblies()\n        .Public.Methods().With<FactAttribute>().OrWith<TheoryAttribute>()\n        .DeclaringTypes())\n    .HaveName("Tests").AsSuffix();\n\n// Verify all async methods have "Async" suffix\nawait Expect.That(In.AssemblyContaining<MyClass>()\n        .Methods().WhichReturn<Task>().OrReturn<ValueTask>())\n    .HaveName("Async").AsSuffix();\n\n// Verify all methods with "Async" suffix return Task or ValueTask\nawait Expect.That(In.AssemblyContaining<MyClass>()\n        .Methods().WithName("Async").AsSuffix())\n    .Return<Task>().OrReturn<ValueTask>();\n\n// Verify controllers follow naming convention\nawait Expect.That(In.AllLoadedAssemblies()\n        .Types().WhichInheritFrom<ControllerBase>())\n    .HaveName("Controller").AsSuffix();\n'})}),"\n",(0,a.jsx)(t.h2,{id:"assemblies",children:"Assemblies"}),"\n",(0,a.jsx)(t.h3,{id:"name",children:"Name"}),"\n",(0,a.jsx)(t.p,{children:"You can verify the name of an assembly or a collection of assemblies:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'Assembly subject = Assembly.GetEntryAssembly();\nAssembly[] subjects = AppDomain.CurrentDomain.GetAssemblies();\n\nawait Expect.That(subject).HasName("aweXpect.Reflection");\nawait Expect.That(subjects).HaveName("aweXpect").AsPrefix();\n'})}),"\n",(0,a.jsxs)(t.p,{children:["You can use the same configuration options as\nwhen ",(0,a.jsx)(t.a,{href:"https://awexpect.com/docs/expectations/string#equality",children:"comparing strings"}),"."]}),"\n",(0,a.jsx)(t.h3,{id:"dependencies",children:"Dependencies"}),"\n",(0,a.jsx)(t.p,{children:"You can verify whether assemblies have specific dependencies:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'Assembly subject = Assembly.GetEntryAssembly();\nAssembly[] subjects = AppDomain.CurrentDomain.GetAssemblies();\n\n// Single assembly\nawait Expect.That(subject).HasADependencyOn("System.Core");\nawait Expect.That(subject).HasNoDependencyOn("UnwantedDependency");\n\n// Multiple assemblies\nawait Expect.That(subjects).HaveADependencyOn("System.Core");\nawait Expect.That(subjects).HaveNoDependencyOn("UnwantedDependency");\n'})}),"\n",(0,a.jsx)(t.h3,{id:"attributes",children:"Attributes"}),"\n",(0,a.jsx)(t.p,{children:"You can verify whether assemblies have specific attributes:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'Assembly subject = Assembly.GetEntryAssembly();\nAssembly[] subjects = AppDomain.CurrentDomain.GetAssemblies();\n\n// Single assembly\nawait Expect.That(subject).Has<AssemblyTitleAttribute>();\nawait Expect.That(subject).Has<AssemblyVersionAttribute>(a => a.Version == "1.0.0");\n\n// Multiple assemblies\nawait Expect.That(subjects).Have<AssemblyTitleAttribute>();\n'})}),"\n",(0,a.jsx)(t.h2,{id:"types",children:"Types"}),"\n",(0,a.jsx)(t.h3,{id:"name--namespace",children:"Name / Namespace"}),"\n",(0,a.jsx)(t.p,{children:"You can verify the name or namespace of a type or a collection of types:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'Type subject = typeof(MyClass);\nIEnumerable<Type> subjects = In.EntryAssembly().Types();\n\nawait Expect.That(subject).HasNamespace("aweXpect").AsPrefix();\nawait Expect.That(subject).HasName("MyClass");\n\nawait Expect.That(subjects).HaveNamespace("aweXpect").AsPrefix();\nawait Expect.That(subjects).HaveName("Tests").AsSuffix();\n'})}),"\n",(0,a.jsxs)(t.p,{children:["You can use the same configuration options as\nwhen ",(0,a.jsx)(t.a,{href:"https://awexpect.com/docs/expectations/string#equality",children:"comparing strings"}),"."]}),"\n",(0,a.jsx)(t.h3,{id:"type-kinds",children:"Type Kinds"}),"\n",(0,a.jsx)(t.p,{children:"You can verify what kind of type you're dealing with:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"Type subject = typeof(MyClass);\nIEnumerable<Type> subjects = In.EntryAssembly().Types();\n\n// Single type\nawait Expect.That(subject).IsAClass();\nawait Expect.That(subject).IsAnInterface();\nawait Expect.That(subject).IsAnEnum();\nawait Expect.That(subject).IsAbstract();\nawait Expect.That(subject).IsSealed();\nawait Expect.That(subject).IsStatic();\nawait Expect.That(subject).IsGeneric();\nawait Expect.That(subject).IsNested();\n\n// Multiple types\nawait Expect.That(subjects).AreClasses();\nawait Expect.That(subjects).AreInterfaces();\nawait Expect.That(subjects).AreEnums();\nawait Expect.That(subjects).AreAbstract();\nawait Expect.That(subjects).AreSealed();\nawait Expect.That(subjects).AreStatic();\nawait Expect.That(subjects).AreGeneric();\nawait Expect.That(subjects).AreNested();\n\n// Negative assertions\nawait Expect.That(subject).IsNotAClass();\nawait Expect.That(subject).IsNotAnInterface();\nawait Expect.That(subject).IsNotAnEnum();\nawait Expect.That(subject).IsNotAbstract();\nawait Expect.That(subject).IsNotSealed();\nawait Expect.That(subject).IsNotStatic();\nawait Expect.That(subject).IsNotGeneric();\nawait Expect.That(subject).IsNotNested();\n\n// Multiple types negative assertions\nawait Expect.That(subjects).AreNotClasses();\nawait Expect.That(subjects).AreNotInterfaces();\nawait Expect.That(subjects).AreNotEnums();\nawait Expect.That(subjects).AreNotAbstract();\nawait Expect.That(subjects).AreNotSealed();\nawait Expect.That(subjects).AreNotStatic();\nawait Expect.That(subjects).AreNotGeneric();\nawait Expect.That(subjects).AreNotNested();\n"})}),"\n",(0,a.jsx)(t.h3,{id:"access-modifiers",children:"Access Modifiers"}),"\n",(0,a.jsx)(t.p,{children:"You can verify the access modifiers of types:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"Type subject = typeof(MyClass);\nIEnumerable<Type> subjects = In.EntryAssembly().Types();\n\n// Single type\nawait Expect.That(subject).IsPublic();\nawait Expect.That(subject).IsInternal();\nawait Expect.That(subject).IsPrivate();\nawait Expect.That(subject).IsProtected();\n\n// Multiple types\nawait Expect.That(subjects).ArePublic();\nawait Expect.That(subjects).AreInternal();\nawait Expect.That(subjects).ArePrivate();\nawait Expect.That(subjects).AreProtected();\n\n// Negative assertions\nawait Expect.That(subject).IsNotPublic();\nawait Expect.That(subject).IsNotInternal();\nawait Expect.That(subject).IsNotPrivate();\nawait Expect.That(subject).IsNotProtected();\n"})}),"\n",(0,a.jsx)(t.h3,{id:"attributes-1",children:"Attributes"}),"\n",(0,a.jsx)(t.p,{children:"You can verify whether types have specific attributes:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'Type subject = typeof(MyClass);\nIEnumerable<Type> subjects = In.EntryAssembly().Types();\n\n// Single type\nawait Expect.That(subject).Has<ObsoleteAttribute>();\nawait Expect.That(subject).Has<ObsoleteAttribute>(a => a.Message == "Use NewClass instead");\n\n// Multiple types\nawait Expect.That(subjects).Have<SerializableAttribute>();\n'})}),"\n",(0,a.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,a.jsx)(t.h3,{id:"name-1",children:"Name"}),"\n",(0,a.jsx)(t.p,{children:"You can verify the names of methods:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'MethodInfo subject = typeof(MyClass).GetMethod("MyMethod");\nIEnumerable<MethodInfo> subjects = typeof(MyClass).GetMethods();\n\n// Single method\nawait Expect.That(subject).HasName("MyMethod");\n\n// Multiple methods\nawait Expect.That(subjects).HaveName("Get").AsPrefix();\n'})}),"\n",(0,a.jsx)(t.h3,{id:"parameters",children:"Parameters"}),"\n",(0,a.jsx)(t.p,{children:"You can verify method parameters:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'MethodInfo subject = typeof(MyClass).GetMethod("MyMethod");\nIEnumerable<MethodInfo> subjects = typeof(MyClass).GetMethods();\n\n// Single method\nawait Expect.That(subject).HasParameter<string>();\nawait Expect.That(subject).HasParameter<string>("parameterName");\nawait Expect.That(subject).HasParameter("parameterName").OfType<int>();\n\n// Multiple methods\nawait Expect.That(subjects).HaveParameter<string>();\nawait Expect.That(subjects).HaveParameter<DateTime>("timestamp");\n'})}),"\n",(0,a.jsx)(t.h3,{id:"return-types",children:"Return Types"}),"\n",(0,a.jsx)(t.p,{children:"You can verify what methods return:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'MethodInfo subject = typeof(MyClass).GetMethod("MyMethod");\nIEnumerable<MethodInfo> subjects = typeof(MyClass).GetMethods();\n\n// Single method\nawait Expect.That(subject).Returns<string>();\nawait Expect.That(subject).ReturnsExactly<string>(); // Exact type match\nawait Expect.That(subject).Returns<Task>(); // Also matches Task<T>\nawait Expect.That(subject).ReturnsExactly<Task>(); // Only matches Task, not Task<T>\n\n// Multiple methods\nawait Expect.That(subjects).Return<Task>();\nawait Expect.That(subjects).ReturnExactly<void>();\n'})}),"\n",(0,a.jsx)(t.h3,{id:"access-modifiers-1",children:"Access Modifiers"}),"\n",(0,a.jsx)(t.p,{children:"You can verify the access modifiers of methods:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'MethodInfo subject = typeof(MyClass).GetMethod("MyMethod");\nIEnumerable<MethodInfo> subjects = typeof(MyClass).GetMethods();\n\n// Single method\nawait Expect.That(subject).IsPublic();\nawait Expect.That(subject).IsPrivate();\nawait Expect.That(subject).IsProtected();\nawait Expect.That(subject).IsInternal();\n\n// Multiple methods\nawait Expect.That(subjects).ArePublic();\nawait Expect.That(subjects).ArePrivate();\nawait Expect.That(subjects).AreProtected();\nawait Expect.That(subjects).AreInternal();\n\n// Negative assertions\nawait Expect.That(subject).IsNotPublic();\nawait Expect.That(subjects).AreNotPrivate();\n'})}),"\n",(0,a.jsx)(t.h3,{id:"attributes-2",children:"Attributes"}),"\n",(0,a.jsx)(t.p,{children:"You can verify whether methods have specific attributes:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'MethodInfo subject = typeof(MyClass).GetMethod("MyMethod");\nIEnumerable<MethodInfo> subjects = typeof(MyClass).GetMethods();\n\n// Single method\nawait Expect.That(subject).Has<ObsoleteAttribute>();\nawait Expect.That(subject).Has<DescriptionAttribute>(a => a.Description == "My method");\n\n// Multiple methods\nawait Expect.That(subjects).Have<AsyncStateMachineAttribute>();\n'})}),"\n",(0,a.jsx)(t.h2,{id:"properties",children:"Properties"}),"\n",(0,a.jsx)(t.h3,{id:"name-and-type",children:"Name and Type"}),"\n",(0,a.jsx)(t.p,{children:"You can verify properties by name:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'PropertyInfo subject = typeof(MyClass).GetProperty("MyProperty");\nIEnumerable<PropertyInfo> subjects = typeof(MyClass).GetProperties();\n\n// Single property\nawait Expect.That(subject).HasName("MyProperty");\n\n// Multiple properties\nawait Expect.That(subjects).HaveName("Id").AsSuffix();\n'})}),"\n",(0,a.jsx)(t.h3,{id:"access-modifiers-2",children:"Access Modifiers"}),"\n",(0,a.jsx)(t.p,{children:"You can verify the access modifiers of properties:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'PropertyInfo subject = typeof(MyClass).GetProperty("MyProperty");\nIEnumerable<PropertyInfo> subjects = typeof(MyClass).GetProperties();\n\n// Single property\nawait Expect.That(subject).IsPublic();\nawait Expect.That(subject).IsPrivate();\nawait Expect.That(subject).IsProtected();\nawait Expect.That(subject).IsInternal();\n\n// Multiple properties\nawait Expect.That(subjects).ArePublic();\nawait Expect.That(subjects).AreInternal();\n\n// Negative assertions\nawait Expect.That(subject).IsNotPrivate();\nawait Expect.That(subjects).AreNotProtected();\n'})}),"\n",(0,a.jsx)(t.h3,{id:"attributes-3",children:"Attributes"}),"\n",(0,a.jsx)(t.p,{children:"You can verify whether properties have specific attributes:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'PropertyInfo subject = typeof(MyClass).GetProperty("MyProperty");\nIEnumerable<PropertyInfo> subjects = typeof(MyClass).GetProperties();\n\n// Single property\nawait Expect.That(subject).Has<RequiredAttribute>();\nawait Expect.That(subject).Has<JsonPropertyNameAttribute>(a => a.Name == "my_property");\n\n// Multiple properties\nawait Expect.That(subjects).Have<JsonIgnoreAttribute>();\n'})}),"\n",(0,a.jsx)(t.h2,{id:"fields",children:"Fields"}),"\n",(0,a.jsx)(t.h3,{id:"name-2",children:"Name"}),"\n",(0,a.jsx)(t.p,{children:"You can verify fields by name:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'FieldInfo subject = typeof(MyClass).GetField("MyField");\nIEnumerable<FieldInfo> subjects = typeof(MyClass).GetFields();\n\n// Single field\nawait Expect.That(subject).HasName("MyField");\n\n// Multiple fields\nawait Expect.That(subjects).HaveName("_").AsPrefix();\n'})}),"\n",(0,a.jsx)(t.h3,{id:"access-modifiers-3",children:"Access Modifiers"}),"\n",(0,a.jsx)(t.p,{children:"You can verify the access modifiers of fields:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'FieldInfo subject = typeof(MyClass).GetField("MyField");\nIEnumerable<FieldInfo> subjects = typeof(MyClass).GetFields();\n\n// Single field\nawait Expect.That(subject).IsPublic();\nawait Expect.That(subject).IsPrivate();\nawait Expect.That(subject).IsProtected();\nawait Expect.That(subject).IsInternal();\n\n// Multiple fields\nawait Expect.That(subjects).ArePrivate();\n\n// Negative assertions\nawait Expect.That(subject).IsNotPublic();\nawait Expect.That(subjects).AreNotPublic();\n'})}),"\n",(0,a.jsx)(t.h3,{id:"attributes-4",children:"Attributes"}),"\n",(0,a.jsx)(t.p,{children:"You can verify whether fields have specific attributes:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'FieldInfo subject = typeof(MyClass).GetField("MyField");\nIEnumerable<FieldInfo> subjects = typeof(MyClass).GetFields();\n\n// Single field\nawait Expect.That(subject).Has<NonSerializedAttribute>();\n\n// Multiple fields\nawait Expect.That(subjects).Have<CompilerGeneratedAttribute>();\n'})}),"\n",(0,a.jsx)(t.h2,{id:"events",children:"Events"}),"\n",(0,a.jsx)(t.h3,{id:"name-3",children:"Name"}),"\n",(0,a.jsx)(t.p,{children:"You can verify event names:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'EventInfo subject = typeof(MyClass).GetEvent("MyEvent");\nIEnumerable<EventInfo> subjects = typeof(MyClass).GetEvents();\n\n// Single event\nawait Expect.That(subject).HasName("MyEvent");\n\n// Multiple events\nawait Expect.That(subjects).HaveName("Changed").AsSuffix();\n'})}),"\n",(0,a.jsx)(t.h3,{id:"access-modifiers-4",children:"Access Modifiers"}),"\n",(0,a.jsx)(t.p,{children:"You can verify the access modifiers of events:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'EventInfo subject = typeof(MyClass).GetEvent("MyEvent");\nIEnumerable<EventInfo> subjects = typeof(MyClass).GetEvents();\n\n// Single event\nawait Expect.That(subject).IsPublic();\nawait Expect.That(subject).IsPrivate();\nawait Expect.That(subject).IsProtected();\nawait Expect.That(subject).IsInternal();\n\n// Multiple events\nawait Expect.That(subjects).ArePublic();\nawait Expect.That(subjects).AreInternal();\n\n// Negative assertions\nawait Expect.That(subject).IsNotPrivate();\nawait Expect.That(subjects).AreNotProtected();\n'})}),"\n",(0,a.jsx)(t.h3,{id:"attributes-5",children:"Attributes"}),"\n",(0,a.jsx)(t.p,{children:"You can verify whether events have specific attributes:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'EventInfo subject = typeof(MyClass).GetEvent("MyEvent");\nIEnumerable<EventInfo> subjects = typeof(MyClass).GetEvents();\n\n// Single event\nawait Expect.That(subject).Has<ObsoleteAttribute>();\n\n// Multiple events\nawait Expect.That(subjects).Have<EditorBrowsableAttribute>();\n'})}),"\n",(0,a.jsx)(t.h2,{id:"constructors",children:"Constructors"}),"\n",(0,a.jsx)(t.h3,{id:"parameters-1",children:"Parameters"}),"\n",(0,a.jsx)(t.p,{children:"You can verify constructor parameters:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'ConstructorInfo subject = typeof(MyClass).GetConstructor(Type.EmptyTypes);\nIEnumerable<ConstructorInfo> subjects = typeof(MyClass).GetConstructors();\n\n// Single constructor\nawait Expect.That(subject).HasParameter<string>();\nawait Expect.That(subject).HasParameter<string>("name");\n\n// Multiple constructors\nawait Expect.That(subjects).HaveParameter<ILogger>();\n'})}),"\n",(0,a.jsx)(t.h3,{id:"attributes-6",children:"Attributes"}),"\n",(0,a.jsx)(t.p,{children:"You can verify whether constructors have specific attributes:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"ConstructorInfo subject = typeof(MyClass).GetConstructor(Type.EmptyTypes);\nIEnumerable<ConstructorInfo> subjects = typeof(MyClass).GetConstructors();\n\n// Single constructor\nawait Expect.That(subject).Has<JsonConstructorAttribute>();\n\n// Multiple constructors\nawait Expect.That(subjects).Have<ObsoleteAttribute>();\n"})}),"\n",(0,a.jsx)(t.h2,{id:"string-matching-options",children:"String Matching Options"}),"\n",(0,a.jsx)(t.p,{children:"When verifying names and other string properties, you have access to the same powerful string matching options as the core aweXpect library:"}),"\n",(0,a.jsx)(t.h3,{id:"exact-matching",children:"Exact Matching"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'await Expect.That(type).HasName("MyClass"); // Exact match\nawait Expect.That(assembly).HasName("MyAssembly"); // Exact match\n'})}),"\n",(0,a.jsx)(t.h3,{id:"prefixsuffix-matching",children:"Prefix/Suffix Matching"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'await Expect.That(types).HaveName("Test").AsPrefix();\nawait Expect.That(types).HaveName("Service").AsSuffix();\nawait Expect.That(types).HaveNamespace("MyApp").AsPrefix();\n'})}),"\n",(0,a.jsx)(t.h3,{id:"case-sensitivity",children:"Case Sensitivity"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'await Expect.That(type).HasName("myclass").IgnoringCase();\nawait Expect.That(types).HaveName("SERVICE").AsSuffix().IgnoringCase();\n'})}),"\n",(0,a.jsx)(t.h3,{id:"wildcards-and-patterns",children:"Wildcards and Patterns"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'await Expect.That(types).HaveName("*Test*").AsWildcard();\nawait Expect.That(methods).HaveName("Get*Async").AsWildcard();\n'})}),"\n",(0,a.jsx)(t.h3,{id:"regular-expressions",children:"Regular Expressions"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'await Expect.That(types).HaveName(@"^Test\\w+$").AsRegex();\nawait Expect.That(methods).HaveName(@"^(Get|Set)\\w+").AsRegex();\n'})}),"\n",(0,a.jsx)(t.h2,{id:"collection-operations",children:"Collection Operations"}),"\n",(0,a.jsx)(t.p,{children:"All expectations work seamlessly with both single items and collections. When working with collections, you can:"}),"\n",(0,a.jsx)(t.h3,{id:"apply-expectations-to-all-items",children:"Apply expectations to all items"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'// All types must be classes\nawait Expect.That(types).AreClasses();\n\n// All methods must be public\nawait Expect.That(methods).ArePublic();\n\n// All assemblies must have a specific dependency\nawait Expect.That(assemblies).HaveADependencyOn("System.Core");\n'})}),"\n",(0,a.jsx)(t.h3,{id:"use-quantifiers",children:"Use quantifiers"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"// At least one type should be abstract\nawait Expect.That(types).Any().IsAbstract();\n\n// All types should be public\nawait Expect.That(types).All().ArePublic();\n\n// Exactly 3 methods should have parameters\nawait Expect.That(methods).Count().Exactly(3).HaveParameter<string>();\n"})}),"\n",(0,a.jsx)(t.h3,{id:"combine-with-linq",children:"Combine with LINQ"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'// Work with filtered collections\nvar publicMethods = typeof(MyClass).GetMethods().Where(m => m.IsPublic);\nawait Expect.That(publicMethods).HaveName("Get").AsPrefix();\n\n// Use complex filtering\nvar complexTypes = In.AllLoadedAssemblies()\n    .Types()\n    .WhichAreClasses()\n    .WhichArePublic()\n    .Where(t => t.GetInterfaces().Length > 2);\nawait Expect.That(complexTypes).HaveName("Manager").AsSuffix();\n'})}),"\n",(0,a.jsx)(t.h2,{id:"configuration-and-customization",children:"Configuration and Customization"}),"\n",(0,a.jsx)(t.h3,{id:"assembly-exclusions",children:"Assembly Exclusions"}),"\n",(0,a.jsxs)(t.p,{children:["By default, system assemblies that start with the following prefixes are excluded from ",(0,a.jsx)(t.code,{children:"In.AllLoadedAssemblies()"}),":"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:'"mscorlib"'}),"\n",(0,a.jsx)(t.li,{children:'"System"'}),"\n",(0,a.jsx)(t.li,{children:'"Microsoft"'}),"\n",(0,a.jsx)(t.li,{children:'"JetBrains"'}),"\n",(0,a.jsx)(t.li,{children:'"xunit"'}),"\n",(0,a.jsx)(t.li,{children:'"Castle"'}),"\n",(0,a.jsx)(t.li,{children:'"DynamicProxyGenAssembly2"'}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["You can customize this behavior through aweXpect's customization system via ",(0,a.jsx)(t.code,{children:"Customize.aweXpect.Reflection().ExcludedAssemblyPrefixes"}),"."]}),"\n",(0,a.jsx)(t.h3,{id:"thread-safety",children:"Thread Safety"}),"\n",(0,a.jsx)(t.p,{children:"All expectations are thread-safe and can be used in parallel tests without issues."}),"\n",(0,a.jsx)(t.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["The ",(0,a.jsx)(t.code,{children:"In"})," helper uses lazy evaluation where possible"]}),"\n",(0,a.jsx)(t.li,{children:"Filtering operations are optimized for common scenarios"}),"\n",(0,a.jsx)(t.li,{children:"Consider caching reflection results if you're performing the same queries repeatedly"}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>c,x:()=>r});var n=s(6540);const a={},i=n.createContext(a);function c(e){const t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);