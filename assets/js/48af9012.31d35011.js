"use strict";(self.webpackChunkpages=self.webpackChunkpages||[]).push([[292],{7114:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"expectations/dates-times","title":"Dates and times","description":"Describes the possible expectations for TimeSpan, DateTime, DateTimeOffset, DateOnly and TimeOnly.","source":"@site/docs/expectations/dates-times.md","sourceDirName":"expectations","slug":"/expectations/dates-times","permalink":"/aweXpect/docs/expectations/dates-times","draft":false,"unlisted":false,"editUrl":"https://github.com/aweXpect/aweXpect/tree/main/Docs/pages/docs/expectations/dates-times.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Numbers","permalink":"/aweXpect/docs/expectations/numbers"},"next":{"title":"Extensibility","permalink":"/aweXpect/docs/category/extensibility"}}');var i=t(4848),s=t(8453);const c={sidebar_position:4},l="Dates and times",r={},o=[{value:"<code>TimeSpan</code>",id:"timespan",level:2},{value:"Equality",id:"equality",level:3},{value:"Greater than / less than",id:"greater-than--less-than",level:3},{value:"Positive / negative",id:"positive--negative",level:3},{value:"<code>DateTime</code>",id:"datetime",level:2},{value:"Equality",id:"equality-1",level:3},{value:"After / before",id:"after--before",level:3},{value:"Property validation",id:"property-validation",level:3},{value:"<code>DateTimeOffset</code>",id:"datetimeoffset",level:2},{value:"Equality",id:"equality-2",level:3},{value:"After / before",id:"after--before-1",level:3},{value:"Property validation",id:"property-validation-1",level:3},{value:"<code>DateOnly</code>",id:"dateonly",level:2},{value:"Equality",id:"equality-3",level:3},{value:"After / before",id:"after--before-2",level:3},{value:"Property validation",id:"property-validation-2",level:3},{value:"<code>TimeOnly</code>",id:"timeonly",level:2},{value:"Equality",id:"equality-4",level:3},{value:"After / before",id:"after--before-3",level:3},{value:"Property validation",id:"property-validation-3",level:3}];function d(e){const a={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(a.header,{children:(0,i.jsx)(a.h1,{id:"dates-and-times",children:"Dates and times"})}),"\n",(0,i.jsxs)(a.p,{children:["Describes the possible expectations for ",(0,i.jsx)(a.code,{children:"TimeSpan"}),", ",(0,i.jsx)(a.code,{children:"DateTime"}),", ",(0,i.jsx)(a.code,{children:"DateTimeOffset"}),", ",(0,i.jsx)(a.code,{children:"DateOnly"})," and ",(0,i.jsx)(a.code,{children:"TimeOnly"}),"."]}),"\n",(0,i.jsx)(a.h2,{id:"timespan",children:(0,i.jsx)(a.code,{children:"TimeSpan"})}),"\n",(0,i.jsx)(a.h3,{id:"equality",children:"Equality"}),"\n",(0,i.jsxs)(a.p,{children:["For asserting whether a ",(0,i.jsx)(a.code,{children:"TimeSpan"})," is equal to another one, use:"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"TimeSpan subject = TimeSpan.FromSeconds(42);\nawait Expect.That(subject).Should().Be(TimeSpan.FromSeconds(42));\n"})}),"\n",(0,i.jsx)(a.p,{children:"You can also specify a tolerance:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"TimeSpan subject = TimeSpan.FromSeconds(42);\nawait Expect.That(subject).Should().Be(TimeSpan.FromSeconds(43))\n  .Within(TimeSpan.FromSeconds(1));\n"})}),"\n",(0,i.jsx)(a.h3,{id:"greater-than--less-than",children:"Greater than / less than"}),"\n",(0,i.jsxs)(a.p,{children:["You can also verify that a ",(0,i.jsx)(a.code,{children:"TimeSpan"})," is greater than or less than another value"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"TimeSpan subject = TimeSpan.FromSeconds(42);\nawait Expect.That(subject).Should().BeGreaterThan(TimeSpan.FromSeconds(41));\nawait Expect.That(subject).Should().BeGreaterThanOrEqualTo(TimeSpan.FromSeconds(42));\nawait Expect.That(subject).Should().BeLessThanOrEqualTo(TimeSpan.FromSeconds(42));\nawait Expect.That(subject).Should().BeLessThan(TimeSpan.FromSeconds(43));\n"})}),"\n",(0,i.jsx)(a.p,{children:"Also for these methods you can specify a tolerance, e.g."}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"TimeSpan subject = TimeSpan.FromSeconds(42);\nawait Expect.That(subject).Should().BeLessThanOrEqualTo(TimeSpan.FromSeconds(41))\n  .Within(TimeSpan.FromSeconds(1));\n"})}),"\n",(0,i.jsx)(a.h3,{id:"positive--negative",children:"Positive / negative"}),"\n",(0,i.jsx)(a.p,{children:"As a special case, to verify, if a number is positive or negative, you can use the following expectations."}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"TimeSpan subject = TimeSpan.FromSeconds(42);\nawait Expect.That(subject).Should().BePositive();\nawait Expect.That(subject).Should().NotBeNegative();\n\nsubject = TimeSpan.FromSeconds(-42);\nawait Expect.That(subject).Should().BeNegative();\nawait Expect.That(subject).Should().NotBePositive();\n"})}),"\n",(0,i.jsx)(a.h2,{id:"datetime",children:(0,i.jsx)(a.code,{children:"DateTime"})}),"\n",(0,i.jsx)(a.h3,{id:"equality-1",children:"Equality"}),"\n",(0,i.jsxs)(a.p,{children:["For asserting whether a ",(0,i.jsx)(a.code,{children:"DateTime"})," is equal to another one, use:"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"DateTime subject = new DateTime(2024, 12, 24);\nawait Expect.That(subject).Should().Be(new DateTime(2024, 12, 24));\n"})}),"\n",(0,i.jsx)(a.p,{children:"You can also specify a tolerance:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"DateTime subject = new DateTime(2024, 12, 24);\nawait Expect.That(subject).Should().Be(new DateTime(2024, 12, 23))\n  .Within(TimeSpan.FromDays(1));\n"})}),"\n",(0,i.jsx)(a.h3,{id:"after--before",children:"After / before"}),"\n",(0,i.jsxs)(a.p,{children:["You can also verify that a ",(0,i.jsx)(a.code,{children:"DateTime"})," is after or before another value"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"DateTime subject = DateTime.Now;\nawait Expect.That(subject).Should().BeAfter(new DateTime(2024, 1, 1));\nawait Expect.That(subject).Should().BeOnOrAfter(new DateTime(2024, 1, 1));\nawait Expect.That(subject).Should().BeBefore(new DateTime(2124, 12, 31));\nawait Expect.That(subject).Should().BeOnOrBefore(new DateTime(2124, 12, 31));\n"})}),"\n",(0,i.jsx)(a.p,{children:"Also for these methods you can specify a tolerance, e.g."}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"DateTime subject = DateTime.Now;\nawait Expect.That(subject).Should().BeOnOrBefore(DateTime.Now)\n  .Within(TimeSpan.FromSeconds(1));\n"})}),"\n",(0,i.jsx)(a.h3,{id:"property-validation",children:"Property validation"}),"\n",(0,i.jsx)(a.p,{children:"You can also verify the value of each individual property:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"DateTime subject = new DateTime(2024, 12, 31, 15, 16, 17, 189, DateTimeKind.Utc);\nawait Expect.That(subject).Should().HaveYear(2024);\nawait Expect.That(subject).Should().HaveMonth(12);\nawait Expect.That(subject).Should().HaveDay(31);\nawait Expect.That(subject).Should().HaveHour(15);\nawait Expect.That(subject).Should().HaveMinute(16);\nawait Expect.That(subject).Should().HaveSecond(17);\nawait Expect.That(subject).Should().HaveMillisecond(189);\nawait Expect.That(subject).Should().HaveKind(DateTimeKind.Utc);\n"})}),"\n",(0,i.jsx)(a.h2,{id:"datetimeoffset",children:(0,i.jsx)(a.code,{children:"DateTimeOffset"})}),"\n",(0,i.jsx)(a.h3,{id:"equality-2",children:"Equality"}),"\n",(0,i.jsxs)(a.p,{children:["For asserting whether a ",(0,i.jsx)(a.code,{children:"DateTimeOffset"})," is equal to another one, use:"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"DateTimeOffset subject = new DateTimeOffset(2024, 12, 24, 13, 15, 0, TimeSpan.FromHours(2));\nawait Expect.That(subject).Should().Be(new DateTimeOffset(2024, 12, 24, 13, 15, 0, TimeSpan.FromHours(2)));\n"})}),"\n",(0,i.jsx)(a.p,{children:"You can also specify a tolerance:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"DateTimeOffset subject = new DateTimeOffset(2024, 12, 24, 13, 15, 0, TimeSpan.FromHours(2));\nawait Expect.That(subject).Should().Be(new DateTimeOffset(2024, 12, 24, 13, 5, 0, TimeSpan.FromHours(2)))\n  .Within(TimeSpan.FromMinutes(10));\n"})}),"\n",(0,i.jsx)(a.h3,{id:"after--before-1",children:"After / before"}),"\n",(0,i.jsxs)(a.p,{children:["You can also verify that a ",(0,i.jsx)(a.code,{children:"DateTimeOffset"})," is after or before another value"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"DateTimeOffset subject = DateTimeOffset.Now;\nawait Expect.That(subject).Should().BeAfter(new DateTimeOffset(2024, 1, 1, 0, 0, 0, TimeSpan.FromHours(2)));\nawait Expect.That(subject).Should().BeOnOrAfter(new DateTimeOffset(2024, 1, 1, 0, 0, 0, TimeSpan.FromHours(2)));\nawait Expect.That(subject).Should().BeBefore(new DateTimeOffset(2124, 12, 31, 23, 59, 59, TimeSpan.FromHours(2)));\nawait Expect.That(subject).Should().BeOnOrBefore(new DateTimeOffset(2124, 12, 31, 23, 59, 59, TimeSpan.FromHours(2)));\n"})}),"\n",(0,i.jsx)(a.p,{children:"Also for these methods you can specify a tolerance, e.g."}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"DateTimeOffset subject = DateTimeOffset.Now;\nawait Expect.That(subject).Should().BeOnOrBefore(DateTimeOffset.Now)\n  .Within(TimeSpan.FromSeconds(1));\n"})}),"\n",(0,i.jsx)(a.h3,{id:"property-validation-1",children:"Property validation"}),"\n",(0,i.jsx)(a.p,{children:"You can also verify the value of each individual property:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"DateTimeOffset subject = new DateTimeOffset(2024, 12, 31, 15, 16, 17, 189, TimeSpan.FromMinutes(90));\nawait Expect.That(subject).Should().HaveYear(2024);\nawait Expect.That(subject).Should().HaveMonth(12);\nawait Expect.That(subject).Should().HaveDay(31);\nawait Expect.That(subject).Should().HaveHour(15);\nawait Expect.That(subject).Should().HaveMinute(16);\nawait Expect.That(subject).Should().HaveSecond(17);\nawait Expect.That(subject).Should().HaveMillisecond(189);\nawait Expect.That(subject).Should().HaveOffset(TimeSpan.FromMinutes(90));\n"})}),"\n",(0,i.jsx)(a.h2,{id:"dateonly",children:(0,i.jsx)(a.code,{children:"DateOnly"})}),"\n",(0,i.jsx)(a.h3,{id:"equality-3",children:"Equality"}),"\n",(0,i.jsxs)(a.p,{children:["For asserting whether a ",(0,i.jsx)(a.code,{children:"DateOnly"})," is equal to another one, use:"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"DateOnly subject = new DateOnly(2024, 12, 24);\nawait Expect.That(subject).Should().Be(new DateOnly(2024, 12, 24));\n"})}),"\n",(0,i.jsx)(a.p,{children:"You can also specify a tolerance:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"DateOnly subject = new DateOnly(2024, 12, 24);\nawait Expect.That(subject).Should().Be(new DateOnly(2024, 12, 23))\n  .Within(TimeSpan.FromDays(1));\n"})}),"\n",(0,i.jsx)(a.h3,{id:"after--before-2",children:"After / before"}),"\n",(0,i.jsxs)(a.p,{children:["You can also verify that a ",(0,i.jsx)(a.code,{children:"DateOnly"})," is after or before another value"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"DateOnly subject = DateOnly.FromDateTime(DateTime.Now);\nawait Expect.That(subject).Should().BeAfter(new DateOnly(2024, 1, 1));\nawait Expect.That(subject).Should().BeOnOrAfter(new DateOnly(2024, 1, 1));\nawait Expect.That(subject).Should().BeBefore(new DateOnly(2124, 12, 31));\nawait Expect.That(subject).Should().BeOnOrBefore(new DateOnly(2124, 12, 31));\n"})}),"\n",(0,i.jsx)(a.p,{children:"Also for these methods you can specify a tolerance, e.g."}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"DateOnly subject = DateOnly.FromDateTime(DateTime.Now);\nawait Expect.That(subject).Should().BeBefore(DateOnly.FromDateTime(DateTime.Now))\n  .Within(TimeSpan.FromDays(1));\n"})}),"\n",(0,i.jsx)(a.h3,{id:"property-validation-2",children:"Property validation"}),"\n",(0,i.jsx)(a.p,{children:"You can also verify the value of each individual property:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"DateOnly subject = new DateOnly(2024, 12, 31);\nawait Expect.That(subject).Should().HaveYear(2024);\nawait Expect.That(subject).Should().HaveMonth(12);\nawait Expect.That(subject).Should().HaveDay(31);\n"})}),"\n",(0,i.jsx)(a.h2,{id:"timeonly",children:(0,i.jsx)(a.code,{children:"TimeOnly"})}),"\n",(0,i.jsx)(a.h3,{id:"equality-4",children:"Equality"}),"\n",(0,i.jsxs)(a.p,{children:["For asserting whether a ",(0,i.jsx)(a.code,{children:"TimeOnly"})," is equal to another one, use:"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"TimeOnly subject = new TimeOnly(14, 15, 16);\nawait Expect.That(subject).Should().Be(new TimeOnly(14, 15, 16));\n"})}),"\n",(0,i.jsx)(a.p,{children:"You can also specify a tolerance:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"TimeOnly subject = new TimeOnly(14, 15, 16);\nawait Expect.That(subject).Should().Be(new TimeOnly(14, 15, 17));\n  .Within(TimeSpan.FromSeconds(1));\n"})}),"\n",(0,i.jsx)(a.h3,{id:"after--before-3",children:"After / before"}),"\n",(0,i.jsxs)(a.p,{children:["You can also verify that a ",(0,i.jsx)(a.code,{children:"TimeOnly"})," is after or before another value"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"TimeOnly subject = TimeOnly.FromDateTime(DateTime.Now);\nawait Expect.That(subject).Should().BeAfter(new TimeOnly(0, 0, 0));\nawait Expect.That(subject).Should().BeOnOrAfter(new TimeOnly(0, 0, 0));\nawait Expect.That(subject).Should().BeBefore(new TimeOnly(23, 59, 59));\nawait Expect.That(subject).Should().BeOnOrBefore(new TimeOnly(23, 59, 59));\n"})}),"\n",(0,i.jsx)(a.p,{children:"Also for these methods you can specify a tolerance, e.g."}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"TimeOnly subject = TimeOnly.FromDateTime(DateTime.Now);\nawait Expect.That(subject).Should().BeBefore(TimeOnly.FromDateTime(DateTime.Now))\n  .Within(TimeSpan.FromSeconds(1));\n"})}),"\n",(0,i.jsx)(a.h3,{id:"property-validation-3",children:"Property validation"}),"\n",(0,i.jsx)(a.p,{children:"You can also verify the value of each individual property:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-csharp",children:"TimeOnly subject = new TimeOnly(15, 16, 17, 189);\nawait Expect.That(subject).Should().HaveHour(15);\nawait Expect.That(subject).Should().HaveMinute(16);\nawait Expect.That(subject).Should().HaveSecond(17);\nawait Expect.That(subject).Should().HaveMillisecond(189);\n"})})]})}function h(e={}){const{wrapper:a}={...(0,s.R)(),...e.components};return a?(0,i.jsx)(a,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,a,t)=>{t.d(a,{R:()=>c,x:()=>l});var n=t(6540);const i={},s=n.createContext(i);function c(e){const a=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function l(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),n.createElement(s.Provider,{value:a},e.children)}}}]);