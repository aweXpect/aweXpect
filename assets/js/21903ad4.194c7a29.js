"use strict";(self.webpackChunkpages=self.webpackChunkpages||[]).push([[6259],{7693:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"extensions/project/Reflection/fluentassertions-comparison","title":"Feature Comparison with FluentAssertions","description":"This document provides a comprehensive comparison between aweXpect.Reflection and FluentAssertions for reflection-based","source":"@site/docs/extensions/project/Reflection/01-fluentassertions-comparison.md","sourceDirName":"extensions/project/Reflection","slug":"/extensions/project/Reflection/fluentassertions-comparison","permalink":"/docs/extensions/project/Reflection/fluentassertions-comparison","draft":false,"unlisted":false,"editUrl":"https://github.com/aweXpect/aweXpect/tree/main/Docs/pages/docs/extensions/project/Reflection/01-fluentassertions-comparison.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"extensionsSidebar","previous":{"title":"[aweXpect.Reflection](https://github.com/aweXpect/aweXpect.Reflection) [![Nuget](https://img.shields.io/nuget/v/aweXpect.Reflection)](https://www.nuget.org/packages/aweXpect.Reflection)","permalink":"/docs/extensions/project/Reflection/index"},"next":{"title":"aweXpect.Testably","permalink":"/docs/extensions/project/Testably/index"}}');var i=s(4848),r=s(8453);const a={},l="Feature Comparison with FluentAssertions",o={},c=[{value:"Overview",id:"overview",level:2},{value:"Feature Comparison Matrix",id:"feature-comparison-matrix",level:2},{value:"Detailed Feature Breakdown",id:"detailed-feature-breakdown",level:2},{value:"1. Assembly Assertions",id:"1-assembly-assertions",level:3},{value:"aweXpect.Reflection",id:"awexpectreflection",level:4},{value:"FluentAssertions",id:"fluentassertions",level:4},{value:"2. Type Assertions",id:"2-type-assertions",level:3},{value:"aweXpect.Reflection",id:"awexpectreflection-1",level:4},{value:"FluentAssertions",id:"fluentassertions-1",level:4},{value:"3. Method Assertions",id:"3-method-assertions",level:3},{value:"aweXpect.Reflection",id:"awexpectreflection-2",level:4},{value:"FluentAssertions",id:"fluentassertions-2",level:4},{value:"4. Property Assertions",id:"4-property-assertions",level:3},{value:"aweXpect.Reflection",id:"awexpectreflection-3",level:4},{value:"FluentAssertions",id:"fluentassertions-3",level:4},{value:"5. Advanced Filtering and Collection Operations",id:"5-advanced-filtering-and-collection-operations",level:3},{value:"aweXpect.Reflection",id:"awexpectreflection-4",level:4},{value:"FluentAssertions",id:"fluentassertions-4",level:4}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"feature-comparison-with-fluentassertions",children:"Feature Comparison with FluentAssertions"})}),"\n",(0,i.jsx)(t.p,{children:"This document provides a comprehensive comparison between aweXpect.Reflection and FluentAssertions for reflection-based\ntesting scenarios. Both libraries offer powerful capabilities for asserting against reflection types, but with different\nsyntax patterns and feature sets."}),"\n",(0,i.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"aweXpect.Reflection"})," is designed as an extension to the aweXpect testing framework, providing expectations for\nreflection types with async/await support and rich filtering capabilities."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"FluentAssertions"})," is a popular general-purpose assertion library that includes extensive reflection testing features\nalongside other assertion types."]}),"\n",(0,i.jsx)(t.h2,{id:"feature-comparison-matrix",children:"Feature Comparison Matrix"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Feature Category"}),(0,i.jsx)(t.th,{children:"aweXpect.Reflection"}),(0,i.jsx)(t.th,{children:"FluentAssertions"}),(0,i.jsx)(t.th,{children:"Notes"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"Assembly Testing"})}),(0,i.jsx)(t.td,{children:"\u2705"}),(0,i.jsx)(t.td,{children:"\u2705"}),(0,i.jsx)(t.td,{children:"Both support assembly-level assertions"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"Type Testing"})}),(0,i.jsx)(t.td,{children:"\u2705"}),(0,i.jsx)(t.td,{children:"\u2705"}),(0,i.jsx)(t.td,{children:"Both support comprehensive type assertions"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"Method Testing"})}),(0,i.jsx)(t.td,{children:"\u2705"}),(0,i.jsx)(t.td,{children:"\u2705"}),(0,i.jsx)(t.td,{children:"Both support method-level assertions"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"Property Testing"})}),(0,i.jsx)(t.td,{children:"\u2705"}),(0,i.jsx)(t.td,{children:"\u2705"}),(0,i.jsx)(t.td,{children:"Both support property assertions"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"Field Testing"})}),(0,i.jsx)(t.td,{children:"\u2705"}),(0,i.jsx)(t.td,{children:"\u2705"}),(0,i.jsx)(t.td,{children:"Both support field assertions"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"Event Testing"})}),(0,i.jsx)(t.td,{children:"\u2705"}),(0,i.jsx)(t.td,{children:"\u2705"}),(0,i.jsx)(t.td,{children:"Both support event assertions"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"Constructor Testing"})}),(0,i.jsx)(t.td,{children:"\u2705"}),(0,i.jsx)(t.td,{children:"\u2705"}),(0,i.jsx)(t.td,{children:"Both support constructor assertions"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"Attribute Testing"})}),(0,i.jsx)(t.td,{children:"\u2705"}),(0,i.jsx)(t.td,{children:"\u2705"}),(0,i.jsx)(t.td,{children:"Both support attribute presence/value testing"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:(0,i.jsx)(t.strong,{children:"Collection Filtering"})}),(0,i.jsx)(t.td,{children:"\u2705"}),(0,i.jsx)(t.td,{children:"\u26a0\ufe0f"}),(0,i.jsxs)(t.td,{children:["aweXpect has more advanced filtering via ",(0,i.jsx)(t.code,{children:"In"})]})]})]})]}),"\n",(0,i.jsxs)(t.p,{children:["| ",(0,i.jsx)(t.strong,{children:"String Matching Options"})," | \u2705 | \u2705 | Both support prefix, suffix, regex, wildcards |\n| ",(0,i.jsx)(t.strong,{children:"Dependency Testing"})," | \u2705 | \u2705 | Both support assembly dependency checks |\n| ",(0,i.jsx)(t.strong,{children:"Access Modifier Testing"})," | \u2705 | \u2705 | Both support public/private/protected/internal |\n| ",(0,i.jsx)(t.strong,{children:"Type Kind Testing"})," | \u2705 | \u2705 | Both support class/interface/enum/abstract/etc |"]}),"\n",(0,i.jsx)(t.h2,{id:"detailed-feature-breakdown",children:"Detailed Feature Breakdown"}),"\n",(0,i.jsx)(t.h3,{id:"1-assembly-assertions",children:"1. Assembly Assertions"}),"\n",(0,i.jsx)(t.h4,{id:"awexpectreflection",children:"aweXpect.Reflection"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'// Single assembly\nawait Expect.That(assembly).HasName("MyAssembly");\nawait Expect.That(assembly).HasADependencyOn("System.Core");\nawait Expect.That(assembly).HasNoDependencyOn("UnwantedDependency");\n\n// Multiple assemblies\nAssembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();\nawait Expect.That(assemblies).HaveName("System").AsPrefix();\n'})}),"\n",(0,i.jsx)(t.h4,{id:"fluentassertions",children:"FluentAssertions"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'// Single assembly\nassembly.Should().HaveAssemblyName("MyAssembly");\nassembly.Should().Reference("System.Core");\nassembly.Should().NotReference("UnwantedDependency");\n\n// Multiple assemblies - requires more manual work\nAssembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();\nassemblies.Should().OnlyContain(a => a.FullName.StartsWith("System"));\n'})}),"\n",(0,i.jsx)(t.h3,{id:"2-type-assertions",children:"2. Type Assertions"}),"\n",(0,i.jsx)(t.h4,{id:"awexpectreflection-1",children:"aweXpect.Reflection"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'// Single type\nawait Expect.That(typeof(MyClass)).IsAClass();\nawait Expect.That(typeof(IMyInterface)).IsAnInterface();\nawait Expect.That(typeof(MyEnum)).IsAnEnum();\nawait Expect.That(typeof(AbstractClass)).IsAbstract();\nawait Expect.That(typeof(MyClass)).HasNamespace("MyNamespace");\nawait Expect.That(typeof(MyClass)).Has<MyAttribute>();\n\n// Multiple types with advanced filtering\nawait Expect.That(In.AllLoadedAssemblies()\n    .Types().WhichAreClasses().WhichArePublic())\n    .HaveNamespace("MyNamespace").AsPrefix();\n'})}),"\n",(0,i.jsx)(t.h4,{id:"fluentassertions-1",children:"FluentAssertions"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'// Single type\ntypeof(MyClass).Should().BeClass();\ntypeof(MyInterface).Should().BeInterface();\ntypeof(MyEnum).Should().BeEnum();\ntypeof(AbstractClass).Should().BeAbstract();\ntypeof(MyClass).Should().BeInNamespace("MyNamespace");\ntypeof(MyClass).Should().BeDecoratedWith<MyAttribute>();\n\n// Multiple types\nvar types = Assembly.GetExecutingAssembly().GetTypes();\ntypes.Should().OnlyContain(t => t.IsClass && t.IsPublic);\n'})}),"\n",(0,i.jsx)(t.h3,{id:"3-method-assertions",children:"3. Method Assertions"}),"\n",(0,i.jsx)(t.h4,{id:"awexpectreflection-2",children:"aweXpect.Reflection"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'// Single method\nMethodInfo method = typeof(MyClass).GetMethod("MyMethod");\nawait Expect.That(method).IsPublic();\nawait Expect.That(method).HasName("MyMethod");\nawait Expect.That(method).Has<ObsoleteAttribute>();\n\n// Multiple methods with filtering\nawait Expect.That(In.AssemblyContaining<MyClass>()\n    .Methods().WhichArePublic().With<TestAttribute>())\n    .HaveName("Test").AsPrefix();\n'})}),"\n",(0,i.jsx)(t.h4,{id:"fluentassertions-2",children:"FluentAssertions"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'// Single method\nMethodInfo method = typeof(MyClass).GetMethod("MyMethod");\nmethod.Should().BePublic();\nmethod.Should().HaveName("MyMethod");\nmethod.Should().BeDecoratedWith<ObsoleteAttribute>();\n\n// Multiple methods\nvar methods = typeof(MyClass).GetMethods();\nmethods.Should().OnlyContain(m => m.IsPublic);\n'})}),"\n",(0,i.jsx)(t.h3,{id:"4-property-assertions",children:"4. Property Assertions"}),"\n",(0,i.jsx)(t.h4,{id:"awexpectreflection-3",children:"aweXpect.Reflection"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'// Single property\nPropertyInfo property = typeof(MyClass).GetProperty("MyProperty");\nawait Expect.That(property).IsPublic();\nawait Expect.That(property).HasName("MyProperty");\n\n// Multiple properties\nawait Expect.That(In.AssemblyContaining<MyClass>()\n    .Properties().WhichArePublic())\n    .HaveName("Id").AsSuffix();\n'})}),"\n",(0,i.jsx)(t.h4,{id:"fluentassertions-3",children:"FluentAssertions"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'// Single property\nPropertyInfo property = typeof(MyClass).GetProperty("MyProperty");\nproperty.Should().BePublic();\nproperty.Should().HaveName("MyProperty");\n\n// Multiple properties\nvar properties = typeof(MyClass).GetProperties();\nproperties.Should().OnlyContain(p => p.GetGetMethod().IsPublic);\n'})}),"\n",(0,i.jsx)(t.h3,{id:"5-advanced-filtering-and-collection-operations",children:"5. Advanced Filtering and Collection Operations"}),"\n",(0,i.jsx)(t.h4,{id:"awexpectreflection-4",children:"aweXpect.Reflection"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'// Complex filtering scenarios\nawait Expect.That(In.AllLoadedAssemblies()\n        .Methods().With<FactAttribute>().OrWith<TheoryAttribute>()\n        .DeclaringTypes())\n    .HaveName("Tests").AsSuffix();\n\n// Filter by return types\nawait Expect.That(In.AssemblyContaining(typeof(In))\n        .Methods().WhichReturn<Task>().OrReturn<ValueTask>())\n    .HaveName("Async").AsSuffix();\n'})}),"\n",(0,i.jsx)(t.h4,{id:"fluentassertions-4",children:"FluentAssertions"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'// Requires more manual LINQ operations\nvar testClasses = AppDomain.CurrentDomain.GetAssemblies()\n    .SelectMany(a => a.GetTypes())\n    .Where(t => t.GetMethods()\n        .Any(m => m.HasAttribute<FactAttribute>() || m.HasAttribute<TheoryAttribute>()));\n\ntestClasses.Should().OnlyContain(t => t.Name.EndsWith("Tests"));\n\n// Return type filtering requires manual work\nvar methods = AppDomain.CurrentDomain.GetAssemblies()\n    .SelectMany(a => a.GetTypes().SelectMany(t => t.GetMethods()))\n    .Where(m => m.ReturnType == typeof(Task) || m.ReturnType == typeof(ValueTask));\nmethods.Should().OnlyContain(m => m.Name.EndsWith("Async"));\n'})})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>l});var n=s(6540);const i={},r=n.createContext(i);function a(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);